#!/usr/bin/env python3
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Main entry point for Lutris"""
import gettext
import locale
import os
import sys
import asyncio
from os.path import dirname, normpath, realpath

LAUNCH_PATH = dirname(realpath(__file__))

# Prevent loading Python modules from home folder
# They can interfere with Lutris and prevent it
# from working.
if os.environ.get("LUTRIS_ALLOW_LOCAL_PYTHON_PACKAGES") != "1":
    sys.path = [path for path in sys.path if not path.startswith("/home") and not path.startswith("/var/home")]

if os.path.isdir(os.path.join(LAUNCH_PATH, "../lutris")):
    sys.dont_write_bytecode = True
    SOURCE_PATH = normpath(os.path.join(LAUNCH_PATH, '..'))
    sys.path.insert(0, SOURCE_PATH)
else:
    sys.path.insert(0, os.path.normpath(os.path.join(LAUNCH_PATH, "../lib/lutris")))

try:
    locale.setlocale(locale.LC_ALL, "")
except locale.Error as ex:
    sys.stderr.write("Unsupported locale setting: %s\n" % ex)

try:
    # optional_settings does not exist if you don't use the meson build system
    from lutris import optional_settings

    try:
        locale.bindtextdomain("lutris", optional_settings.LOCALE_DIR)
        gettext.bindtextdomain("lutris", optional_settings.LOCALE_DIR)
        locale.textdomain("lutris")
        gettext.textdomain("lutris")
    except:
        sys.stderr.write(
            "Couldn't bind gettext domain, translations won't work.\n"
            "LOCALE_DIR: %s\n" % optional_settings.LOCALE_DIR
        )
except ImportError:
    pass

import gi

gi.require_version("Gdk", "3.0")
gi.require_version("Gtk", "3.0")

from gi.repository import Gio, GLib, Gtk, GObject
from lutris.gui.application import Application  # pylint: disable=no-name-in-module

app = Application()  # pylint: disable=invalid-name


async def start(app):
    app.do_local_command_line(app, sys.argv)
    app.register()
    app.activate()


def glib_update(main_context, loop):
    while main_context.pending():
        main_context.iteration(False)
    loop.call_later(0.01, glib_update, main_context, loop)


async def _run_async(dialog):
    was_modal = dialog.get_modal()
    destroyed = False
    response_id = Gtk.ResponseType.NONE
    ended = loop.create_future()

    def shutdown_loop():
        if not ended.done():
            ended.set_result(None)

    def on_response(_dialog, response):
        nonlocal response_id
        response_id = response
        shutdown_loop()

    def on_unmap(_dialog, *_args):
        shutdown_loop()

    def on_delete(_dialog, *_args):
        shutdown_loop()
        return True  # do not destroy

    def on_destroy(_dialog, *_args):
        nonlocal destroyed
        destroyed = True

    dialog.set_modal(True)
    dialog.show()

    source_ids = [
        dialog.connect("response", on_response),
        dialog.connect("unmap", on_unmap),
        dialog.connect("delete-event", on_delete),
        dialog.connect("destroy", on_destroy),
    ]

    try:
        await ended
        return response_id
    finally:
        if not destroyed:
            dialog.set_modal(was_modal)
            for source_id in source_ids:
                dialog.disconnect(source_id)


Gtk.Dialog.run_async = _run_async

loop = asyncio.get_event_loop()
main_context = GLib.MainContext.default()
loop.create_task(start(app))
glib_update(main_context, loop)
loop.run_forever()
